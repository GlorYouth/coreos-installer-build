# 工作流名称
name: Daily coreos-installer Official Release Build and Publish (MUSL Static Linking)

# 工作流触发条件
on:
  schedule:
    - cron: '0 0 * * *' # 每天 UTC 时间 00:00 (午夜) 运行
  push:
    branches:
      - main # 每次推送到 main 分支时自动运行
  workflow_dispatch:
    # 允许手动触发此工作流
    inputs:
      force_release:
        description: '强制发布新版本，即使版本号没有变化' # 完全使用中文描述
        required: false
        default: false
        type: boolean

jobs:
  # 步骤 1: 获取最新 Release 信息并决定是否需要发布
  get-latest-release-info:
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.get_official_release.outputs.official_release_tag }}     # 输出官方 coreos-installer 的最新 Release 标签
      release_url: ${{ steps.get_official_release.outputs.official_zipball_url }}    # 输出官方 coreos-installer 最新 Release 的源码下载 URL
      release_version_prefix: ${{ steps.get_official_release.outputs.official_version_prefix }} # 输出从官方标签提取的版本前缀
      date_tag: ${{ steps.get_date.outputs.date_tag }}                     # 输出当前日期标签 (例如 20231026)
      date_name: ${{ steps.get_date.outputs.date_name }}                   # 输出当前日期名称 (例如 2023-10-26)
      needs_release: ${{ steps.determine_release_need.outputs.needs_release }}   # 输出是否需要发布新版本的标志 (true/false)
    permissions:
      contents: read # 检出代码和进行 API 调用（针对本仓库）通常需要读取权限

    steps:
      - name: Checkout your repository # 检出当前仓库代码
        uses: actions/checkout@v4

      - name: Get latest coreos-installer official release info # 获取 coreos-installer 官方最新 Release 信息
        id: get_official_release
        run: |
          # 安装 jq
          sudo apt-get update && sudo apt-get install -y jq
          OFFICIAL_RELEASE_INFO=$(curl -s -L "https://api.github.com/repos/coreos/coreos-installer/releases/latest")
          if [ -z "$OFFICIAL_RELEASE_INFO" ] || [ "$(echo "$OFFICIAL_RELEASE_INFO" | jq -r .message)" = "Not Found" ]; then
            echo "错误：未能从 coreos/coreos-installer 获取最新的 Release 信息。"
            exit 1
          fi
          OFFICIAL_TAG_NAME=$(echo "$OFFICIAL_RELEASE_INFO" | jq -r .tag_name)
          OFFICIAL_ZIPBALL_URL=$(echo "$OFFICIAL_RELEASE_INFO" | jq -r .zipball_url)
          OFFICIAL_VERSION_PREFIX=$(echo "$OFFICIAL_TAG_NAME" | sed 's/^v//')

          if [ -z "$OFFICIAL_TAG_NAME" ] || [ "$OFFICIAL_TAG_NAME" = "null" ]; then echo "错误：无法从官方 Release 信息中提取 tag_name。" >&2; exit 1; fi
          if [ -z "$OFFICIAL_ZIPBALL_URL" ] || [ "$OFFICIAL_ZIPBALL_URL" = "null" ]; then echo "错误：无法从官方 Release 信息中提取 zipball_url。" >&2; exit 1; fi
          if [ -z "$OFFICIAL_VERSION_PREFIX" ] || [ "$OFFICIAL_VERSION_PREFIX" = "null" ]; then echo "错误：无法从官方 tag_name ($OFFICIAL_TAG_NAME) 中确定 version_prefix。" >&2; exit 1; fi

          echo "官方 coreos-installer 最新 Release 标签: $OFFICIAL_TAG_NAME"
          echo "官方 coreos-installer 最新 zipball URL: $OFFICIAL_ZIPBALL_URL"
          echo "官方 coreos-installer 版本前缀: $OFFICIAL_VERSION_PREFIX"

          echo "official_release_tag=$OFFICIAL_TAG_NAME" >> "$GITHUB_OUTPUT"
          echo "official_zipball_url=$OFFICIAL_ZIPBALL_URL" >> "$GITHUB_OUTPUT"
          echo "official_version_prefix=$OFFICIAL_VERSION_PREFIX" >> "$GITHUB_OUTPUT"

      - name: Get Current Date # 获取当前日期
        id: get_date
        run: |
          CURRENT_DATE_TAG=$(date +%Y%m%d)
          CURRENT_DATE_NAME=$(date +%Y-%m-%d)
          echo "date_tag=$CURRENT_DATE_TAG" >> "$GITHUB_OUTPUT"
          echo "date_name=$CURRENT_DATE_NAME" >> "$GITHUB_OUTPUT"
          echo "当前日期标签: $CURRENT_DATE_TAG"
          echo "当前日期名称: $CURRENT_DATE_NAME"

      - name: Get latest own repository release info # 获取本仓库的最新 Release 信息
        id: get_own_latest_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 使用 GITHUB_TOKEN 进行认证
        run: |
          OWN_RELEASE_INFO=$(curl -s -L -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ github.repository }}/releases/latest")
          OWN_LATEST_RELEASE_TAG="" # 默认为空字符串

          # 检查API调用是否成功并且返回了有效的JSON
          if echo "$OWN_RELEASE_INFO" | jq -e .tag_name > /dev/null 2>&1; then
            OWN_LATEST_RELEASE_TAG=$(echo "$OWN_RELEASE_INFO" | jq -r .tag_name)
            echo "本仓库最新 Release 标签: $OWN_LATEST_RELEASE_TAG"
          else
            # 如果 jq 失败 (例如因为 "Not Found" 消息不是有效 JSON 或 .tag_name 不存在)
            echo "本仓库中未找到 Release，或无法解析最新的 Release 信息。"
            # OWN_LATEST_RELEASE_TAG 保持为空
          fi
          echo "own_latest_release_tag=$OWN_LATEST_RELEASE_TAG" >> "$GITHUB_OUTPUT"

      - name: Determine if Release is Needed # 根据版本比较决定是否需要发布
        id: determine_release_need
        run: |
          CURRENT_OFFICIAL_TAG="${{ steps.get_official_release.outputs.official_release_tag }}"
          OWN_LATEST_TAG_FULL="${{ steps.get_own_latest_release.outputs.own_latest_release_tag }}"
          
          PREVIOUS_OFFICIAL_EQUIVALENT_TAG=""
          if [ -n "$OWN_LATEST_TAG_FULL" ] && [ "$OWN_LATEST_TAG_FULL" != "null" ]; then
            # 从本仓库的 Release 标签 (例如 v0.24.0-20250521-musl) 提取核心版本部分 (例如 v0.24.0)
            PREVIOUS_OFFICIAL_EQUIVALENT_TAG=$(echo "$OWN_LATEST_TAG_FULL" | sed 's/-musl$//' | cut -d'-' -f1)
            echo "本仓库最新 Release 标签中的核心版本部分: $PREVIOUS_OFFICIAL_EQUIVALENT_TAG"
          else
            echo "本仓库中未找到之前的有效 Release 标签。"
          fi

          NEEDS_RELEASE="false"
          EVENT_NAME="${{ github.event_name }}"
          FORCE_RELEASE_INPUT="${{ github.event.inputs.force_release }}"

          echo "当前事件名称: $EVENT_NAME"
          echo "强制发布输入: $FORCE_RELEASE_INPUT"
          echo "CoreOS/coreos-installer 最新官方 Release 标签: $CURRENT_OFFICIAL_TAG"

          if [ "$EVENT_NAME" = "push" ]; then
              NEEDS_RELEASE="true"
              echo "工作流由 push 事件触发。需要发布新版本 (跳过版本号比较)。"
          elif [ "$FORCE_RELEASE_INPUT" = "true" ]; then
              NEEDS_RELEASE="true"
              echo "强制发布输入为 true。需要发布新版本 (跳过版本号比较)。"
          elif [ -z "$PREVIOUS_OFFICIAL_EQUIVALENT_TAG" ]; then
              NEEDS_RELEASE="true"
              echo "本仓库中未找到之前的有效 Release 或无法解析其核心版本。需要发布新版本。"
          elif [ "$CURRENT_OFFICIAL_TAG" != "$PREVIOUS_OFFICIAL_EQUIVALENT_TAG" ]; then
              NEEDS_RELEASE="true"
              echo "官方 coreos-installer 版本已更新 (官方最新: $CURRENT_OFFICIAL_TAG, 本仓库上次构建基于的官方版本: $PREVIOUS_OFFICIAL_EQUIVALENT_TAG)。需要发布新版本。"
          else
              echo "官方 coreos-installer 版本未发生变化 (均为 $CURRENT_OFFICIAL_TAG，与本仓库上次构建基于的官方版本一致)。不需要发布新版本。"
          fi
          echo "needs_release=$NEEDS_RELEASE" >> "$GITHUB_OUTPUT"

  # 步骤 2: 多架构构建 Job (MUSL)
  build-multi-arch-musl:
    name: Build for ${{ matrix.target.name }} (MUSL)
    needs: get-latest-release-info # 依赖于获取 Release 信息 Job
    # 仅当 "get-latest-release-info" 步骤指示需要发布时才执行此 Job
    if: ${{ success() && needs.get-latest-release-info.outputs.needs_release == 'true' }}
    runs-on: ubuntu-latest
    env: # 将所需变量提升到 Job 级别环境变量
      RELEASE_ZIP_URL: ${{ needs.get-latest-release-info.outputs.release_url }}
      COREOS_INSTALLER_OFFICIAL_TAG: ${{ needs.get-latest-release-info.outputs.release_tag }} # 这是官方的标签
      RELEASE_VERSION_PREFIX: ${{ needs.get-latest-release-info.outputs.release_version_prefix }}
      ARM64_UBUNTU_PORTS_SOURCES: | # 为 arm64 定义 APT 源文件内容 (来自 ports.ubuntu.com)
        Types: deb
        URIs: http://ports.ubuntu.com/ubuntu-ports
        Suites: noble noble-updates noble-backports noble-security
        Components: main restricted universe multiverse
        Architectures: arm64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
      AMD64_ONLY_UBUNTU_SOURCES: | # 定义一个仅用于 amd64 的主要 Ubuntu 源文件内容
        Types: deb
        URIs: http://azure.archive.ubuntu.com/ubuntu/
        Suites: noble noble-updates noble-backports
        Components: main restricted universe multiverse
        Architectures: amd64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg

        Types: deb
        URIs: http://security.ubuntu.com/ubuntu/
        Suites: noble-security
        Components: main restricted universe multiverse
        Architectures: amd64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
    strategy:
      matrix:
        target:
          - name: x86_64-linux-musl
            rust_target: x86_64-unknown-linux-musl
            arch_suffix: x86_64-musl
            c_compiler: musl-gcc 
            target_cflags: "-I/usr/include/x86_64-linux-gnu" # Target specific CFLAGS for headers
            target_lib_path: "/usr/lib/x86_64-linux-gnu"
            target_pkgconfig_libdir: "/usr/lib/x86_64-linux-gnu/pkgconfig"
          - name: arm64-linux-musl
            rust_target: aarch64-unknown-linux-musl
            arch_suffix: aarch64-musl
            c_compiler: aarch64-linux-gnu-gcc 
            target_cflags: "-I/usr/include/aarch64-linux-gnu" # Target specific CFLAGS for headers
            target_lib_path: "/usr/lib/aarch64-linux-gnu"
            target_pkgconfig_libdir: "/usr/lib/aarch64-linux-gnu/pkgconfig"
    permissions:
      contents: read # 只需读取源码
      actions: write # 授予写入权限以上传 artifacts
    steps:
      - name: Checkout your repository # 检出当前仓库代码
        uses: actions/checkout@v4

      - name: Download coreos-installer official release source # 下载 coreos-installer 官方 Release 源码
        id: download_source
        run: |
          echo "正在从 ${{ env.RELEASE_ZIP_URL }} 下载源码..."
          curl -L "${{ env.RELEASE_ZIP_URL }}" -o coreos-installer-source.zip
          if [ ! -f coreos-installer-source.zip ]; then
            echo "错误：未能下载 coreos-installer-source.zip。"
            exit 1
          fi
          unzip -q coreos-installer-source.zip -d coreos-installer-source
          COREOS_INSTALLER_DIR=$(ls -d coreos-installer-source/*/)
          if [ -z "$COREOS_INSTALLER_DIR" ]; then
            echo "错误：解压后未能找到 coreos-installer 源码目录。"
            exit 1
          fi
          echo "coreos_installer_dir=$COREOS_INSTALLER_DIR" >> "$GITHUB_OUTPUT"

      - name: Install build dependencies for ${{ matrix.target.name }} # 为 ${{ matrix.target.name }} 安装构建依赖
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools pkg-config libzstd-dev 
          
          if [ "${{ matrix.target.rust_target }}" = "aarch64-unknown-linux-musl" ]; then
            echo "为 aarch64-musl 配置 APT 以支持多架构依赖..."
            sudo dpkg --add-architecture arm64
            echo "$AMD64_ONLY_UBUNTU_SOURCES" | sudo tee /etc/apt/sources.list.d/ubuntu.sources > /dev/null
            echo "$ARM64_UBUNTU_PORTS_SOURCES" | sudo tee /etc/apt/sources.list.d/arm64-ubuntu-ports.sources > /dev/null
            sudo apt-get clean
            sudo apt-get update -o Acquire::Retries=3 -o APT::Get::Always-Include-Phased-Updates=true
            sudo apt-get install -y -o Acquire::Retries=3 crossbuild-essential-arm64 libssl-dev:arm64 libzstd-dev:arm64
            
            echo "验证 aarch64 OpenSSL .pc 和 .a 文件..."
            if ! ls -l /usr/lib/aarch64-linux-gnu/pkgconfig/openssl.pc /usr/lib/aarch64-linux-gnu/libssl.a /usr/lib/aarch64-linux-gnu/libcrypto.a > /dev/null 2>&1; then
                echo "错误: aarch64 的 OpenSSL .pc 或 .a 文件未找到。" ; exit 1
            fi
            echo "验证 aarch64 Zstd .pc 和 .a 文件..."
            if ! ls -l /usr/lib/aarch64-linux-gnu/pkgconfig/libzstd.pc /usr/lib/aarch64-linux-gnu/libzstd.a > /dev/null 2>&1; then
                echo "错误: aarch64 的 Zstd .pc 或 .a 文件未找到。" ; exit 1
            fi
          else # x86_64-unknown-linux-musl
            echo "正在为主机 musl 构建安装 libssl-dev..."
            sudo apt-get install -y libssl-dev
            echo "验证主机 OpenSSL 和 Zstd .pc 和 .a 文件..."
            if ! ls -l /usr/lib/x86_64-linux-gnu/pkgconfig/openssl.pc /usr/lib/x86_64-linux-gnu/libssl.a /usr/lib/x86_64-linux-gnu/libcrypto.a > /dev/null 2>&1; then
                echo "错误: 主机的 OpenSSL .pc 或 .a 文件未在 /usr/lib/x86_64-linux-gnu/ 中找到。" ; exit 1
            fi
            if ! ls -l /usr/lib/x86_64-linux-gnu/pkgconfig/libzstd.pc /usr/lib/x86_64-linux-gnu/libzstd.a > /dev/null 2>&1; then
                echo "错误: 主机的 Zstd .pc 或 .a 文件未在 /usr/lib/x86_64-linux-gnu/ 中找到。" ; exit 1
            fi
            echo "主机 OpenSSL 和 Zstd 的 .pc 和 .a 文件已找到。"
          fi

      - name: Setup Rust toolchain for ${{ matrix.target.name }} # 为 ${{ matrix.target.name }} 设置 Rust 工具链
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true
          target: ${{ matrix.target.rust_target }}

      - name: Build coreos-installer for ${{ matrix.target.name }} # 为 ${{ matrix.target.name }} 构建 coreos-installer
        env: 
          CARGO_PROFILE_RELEASE_OPT_LEVEL: "z"
          CARGO_PROFILE_RELEASE_LTO: "fat"
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
          CARGO_PROFILE_RELEASE_PANIC: "abort"
          CARGO_PROFILE_RELEASE_STRIP: "symbols"
          OPENSSL_STATIC: "true" 
          ZSTD_STATIC: "true"
        run: |
          echo "开始为 ${{ matrix.target.name }} (Rust target: ${{ matrix.target.rust_target }}) 构建 coreos-installer..."
          cd "${{ steps.download_source.outputs.coreos_installer_dir }}"
          
          # 清理所有可能冲突的环境变量，然后精确设置
          unset OPENSSL_DIR OPENSSL_LIB_DIR OPENSSL_INCLUDE_DIR 
          unset PKG_CONFIG PKG_CONFIG_PATH PKG_CONFIG_LIBDIR PKG_CONFIG_SYSROOT_DIR
          unset CFLAGS CXXFLAGS CPPFLAGS LDFLAGS # 清空全局 C/C++ 编译和链接标志

          if [[ "${{ matrix.target.rust_target }}" == "x86_64-unknown-linux-musl" ]]; then
            export CC="${{ matrix.target.c_compiler }}" 
            export CXX="musl-g++"
            export CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER="${{ matrix.target.c_compiler }}"
            
            # 为 openssl-sys 设置特定环境变量
            export OPENSSL_DIR="/usr" 
            export OPENSSL_LIB_DIR="${{ matrix.target.target_lib_path }}"
            export OPENSSL_INCLUDE_DIR="${{ matrix.target.target_lib_path }}/../include" # 通常是 /usr/include 或 /usr/include/x86_64-linux-gnu
            # 更精确地指向包含 openssl 子目录的路径
            if [ -d "/usr/include/x86_64-linux-gnu/openssl" ]; then
              export OPENSSL_INCLUDE_DIR="/usr/include/x86_64-linux-gnu"
            elif [ -d "/usr/include/openssl" ]; then
              export OPENSSL_INCLUDE_DIR="/usr/include"
            fi

            # 为 zstd-sys (及其他) 配置 pkg-config
            HOST_PKG_CONFIG=$(command -v pkg-config)
            if [ -z "$HOST_PKG_CONFIG" ]; then echo "错误: 主机 pkg-config 未找到。" >&2; exit 1; fi
            export PKG_CONFIG="$HOST_PKG_CONFIG"
            export PKG_CONFIG_LIBDIR="${{ matrix.target.target_pkgconfig_libdir }}"

            export RUSTFLAGS="-Lnative=${{ matrix.target.target_lib_path }}"
            export LIBRARY_PATH="${{ matrix.target.target_lib_path }}:${LIBRARY_PATH:-}"
            # 设置目标特定的 CFLAGS，主要用于 openssl-sys 的 build.rs 编译 C 代码时查找头文件
            export CFLAGS_x86_64_unknown_linux_musl="${{ matrix.target.target_cflags }}"

            echo "  (x86_64-musl) CC: $CC, CXX: $CXX, LINKER: $CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER"
            echo "  (x86_64-musl) OPENSSL_DIR: $OPENSSL_DIR, OPENSSL_LIB_DIR: $OPENSSL_LIB_DIR, OPENSSL_INCLUDE_DIR: $OPENSSL_INCLUDE_DIR"
            echo "  (x86_64-musl) PKG_CONFIG: $PKG_CONFIG, PKG_CONFIG_LIBDIR: $PKG_CONFIG_LIBDIR"
            echo "  (x86_64-musl) RUSTFLAGS: $RUSTFLAGS, LIBRARY_PATH: $LIBRARY_PATH"
            echo "  (x86_64-musl) CFLAGS_x86_64_unknown_linux_musl: $CFLAGS_x86_64_unknown_linux_musl"
            $PKG_CONFIG --static --debug --cflags --libs openssl || echo "pkg-config openssl (static) 失败"
            $PKG_CONFIG --static --debug --cflags --libs libzstd || echo "pkg-config libzstd (static) 失败"

          elif [[ "${{ matrix.target.rust_target }}" == "aarch64-unknown-linux-musl" ]]; then
            export CC="${{ matrix.target.c_compiler }}" 
            export CXX="aarch64-linux-gnu-g++"
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER="${{ matrix.target.c_compiler }}"

            export OPENSSL_DIR="/usr"
            export OPENSSL_LIB_DIR="${{ matrix.target.target_lib_path }}"
            export OPENSSL_INCLUDE_DIR="${{ matrix.target.target_lib_path }}/../include" # 通常是 /usr/include/aarch64-linux-gnu
            if [ -d "/usr/include/aarch64-linux-gnu/openssl" ]; then
              export OPENSSL_INCLUDE_DIR="/usr/include/aarch64-linux-gnu"
            elif [ -d "/usr/include/openssl" ]; then # Fallback for some systems
                export OPENSSL_INCLUDE_DIR="/usr/include"
            fi
            
            HOST_PKG_CONFIG=$(command -v pkg-config)
            if [ -z "$HOST_PKG_CONFIG" ]; then echo "错误: 主机 pkg-config 未找到。" >&2; exit 1; fi
            export PKG_CONFIG="$HOST_PKG_CONFIG"
            export PKG_CONFIG_ALLOW_CROSS_COMPILE=true
            export PKG_CONFIG_LIBDIR="${{ matrix.target.target_pkgconfig_libdir }}"
            
            export RUSTFLAGS="-Lnative=${{ matrix.target.target_lib_path }}" 
            export LIBRARY_PATH="${{ matrix.target.target_lib_path }}:${LIBRARY_PATH:-}"
            export CFLAGS_aarch64_unknown_linux_musl="${{ matrix.target.target_cflags }}"
            
            echo "  (aarch64-musl) CC: $CC, CXX: $CXX, LINKER: $CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER"
            echo "  (aarch64-musl) OPENSSL_DIR: $OPENSSL_DIR, OPENSSL_LIB_DIR: $OPENSSL_LIB_DIR, OPENSSL_INCLUDE_DIR: $OPENSSL_INCLUDE_DIR"
            echo "  (aarch64-musl) PKG_CONFIG: $PKG_CONFIG, PKG_CONFIG_LIBDIR: $PKG_CONFIG_LIBDIR"
            echo "  (aarch64-musl) RUSTFLAGS: $RUSTFLAGS, LIBRARY_PATH: $LIBRARY_PATH"
            echo "  (aarch64-musl) CFLAGS_aarch64_unknown_linux_musl: $CFLAGS_aarch64_unknown_linux_musl"
            $PKG_CONFIG --static --debug --cflags --libs openssl || echo "pkg-config openssl (static, aarch64) 失败"
            $PKG_CONFIG --static --debug --cflags --libs libzstd || echo "pkg-config libzstd (static, aarch64) 失败"
          fi
          
          cargo build --release --locked --target ${{ matrix.target.rust_target }}
          echo "为 ${{ matrix.target.name }} 构建完成。"
          
          cp "target/${{ matrix.target.rust_target }}/release/coreos-installer" "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}"

      - name: Calculate SHA256 for ${{ matrix.target.name }} 
        run: |
          sha256sum "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}" > "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}.sha256"
          cat "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}.sha256"

      - name: Upload Artifacts for ${{ matrix.target.name }}
        uses: actions/upload-artifact@v4
        with:
          name: coreos-installer-${{ matrix.target.arch_suffix }}
          path: |
            ./coreos-installer-${{ matrix.target.arch_suffix }}
            ./coreos-installer-${{ matrix.target.arch_suffix }}.sha256

  # 步骤 3: 创建 Release Job (MUSL)
  create-release-musl:
    name: Create MUSL Release
    needs: [get-latest-release-info, build-multi-arch-musl] 
    runs-on: ubuntu-latest
    permissions:
      contents: write 
      actions: read   
    if: ${{ success() && needs.get-latest-release-info.outputs.needs_release == 'true' }}
    env: 
      DATE_TAG: ${{ needs.get-latest-release-info.outputs.date_tag }}
      OFFICIAL_TAG: ${{ needs.get-latest-release-info.outputs.release_tag }}
      VERSION_PREFIX: ${{ needs.get-latest-release-info.outputs.release_version_prefix }}
      DATE_NAME: ${{ needs.get-latest-release-info.outputs.date_name }}
    steps:
      - name: Download all coreos-installer MUSL artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./downloaded_release_assets/ 

      - name: List downloaded artifacts 
        run: ls -R ./downloaded_release_assets/

      - name: Prepare release assets 
        run: |
          mkdir -p release_assets 
          
          echo "准备 x86_64-musl 版本化资产..."
          cp "./downloaded_release_assets/coreos-installer-x86_64-musl/coreos-installer-x86_64-musl" \
             "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-musl"
          cp "./downloaded_release_assets/coreos-installer-x86_64-musl/coreos-installer-x86_64-musl.sha256" \
             "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-musl.sha256"

          echo "准备 aarch64-musl 版本化资产..."
          cp "./downloaded_release_assets/coreos-installer-aarch64-musl/coreos-installer-aarch64-musl" \
             "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-musl"
          cp "./downloaded_release_assets/coreos-installer-aarch64-musl/coreos-installer-aarch64-musl.sha256" \
             "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-musl.sha256"

          echo "准备 x86_64-musl 固定名称资产 (latest)..."
          cp "./downloaded_release_assets/coreos-installer-x86_64-musl/coreos-installer-x86_64-musl" \
             "release_assets/coreos-installer-x86_64-musl-latest"
          cp "./downloaded_release_assets/coreos-installer-x86_64-musl/coreos-installer-x86_64-musl.sha256" \
             "release_assets/coreos-installer-x86_64-musl-latest.sha256"

          echo "准备 aarch64-musl 固定名称资产 (latest)..."
          cp "./downloaded_release_assets/coreos-installer-aarch64-musl/coreos-installer-aarch64-musl" \
             "release_assets/coreos-installer-aarch64-musl-latest"
          cp "./downloaded_release_assets/coreos-installer-aarch64-musl/coreos-installer-aarch64-musl.sha256" \
             "release_assets/coreos-installer-aarch64-musl-latest.sha256"
          
          echo "正在生成总的 SHA256SUMS 文件 (MUSL)..."
          (cd release_assets && sha256sum \
            coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-musl \
            coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-musl \
            coreos-installer-x86_64-musl-latest \
            coreos-installer-aarch64-musl-latest \
          ) > release_assets/SHA256SUMS-musl 

          echo "Release MUSL 资产准备完成。目录 'release_assets' 内容:"
          ls -l release_assets/

      - name: Create Release (MUSL) 
        uses: softprops/action-gh-release@v1 
        with:
          tag_name: ${{ env.OFFICIAL_TAG }}-${{ env.DATE_TAG }}-musl 
          name: coreos-installer 官方构建 ${{ env.OFFICIAL_TAG }} (MUSL 静态链接, ${{ env.DATE_NAME }})
          body: |
            ### `coreos-installer` 官方版本的自动化多架构构建 (MUSL 静态链接)

            这是基于 `coreos-installer` 官方 **${{ env.OFFICIAL_TAG }}** Release 的自动化多架构构建版本，使用 MUSL Libc 进行静态链接。

            **官方 Release 标签:** ${{ env.OFFICIAL_TAG }}
            **本次构建日期:** ${{ env.DATE_NAME }}
            **触发本次构建的提交 (本仓库):** ${{ github.sha }}

            **包含的资产 (MUSL):**
            *版本化资产:*
            - `coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-musl`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-musl.sha256`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-musl`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-musl.sha256`

            *固定名称最新资产 (指向此 Release 中的对应架构 MUSL 文件):*
            - `coreos-installer-x86_64-musl-latest`
            - `coreos-installer-x86_64-musl-latest.sha256`
            - `coreos-installer-aarch64-musl-latest`
            - `coreos-installer-aarch64-musl-latest.sha256`
            
            - `SHA256SUMS-musl` (包含以上所有 MUSL 二进制文件的校验和)

            *注意: 此构建基于官方发布的源码。请在使用前验证校验和。*
          files: release_assets/* 
          env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
