# 工作流名称
name: Daily coreos-installer Official Release Build and Publish

# 工作流触发条件
on:
  schedule:
    - cron: '0 0 * * *' # 每天 UTC 时间 00:00 (午夜) 运行
  push:
    branches:
      - main # 每次推送到 main 分支时自动运行
  workflow_dispatch:
    # 允许手动触发此工作流
    inputs:
      force_release:
        description: '强制发布新版本，即使版本号没有变化' # 完全使用中文描述
        required: false
        default: false
        type: boolean

jobs:
  # 步骤 1: 获取最新 Release 信息并决定是否需要发布
  get-latest-release-info:
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.get_release.outputs.tag_name }}               # 输出最新的官方 Release 标签 (例如 v0.20.0)
      release_url: ${{ steps.get_release.outputs.zipball_url }}           # 输出最新官方 Release 的源码下载 URL
      release_version_prefix: ${{ steps.get_release.outputs.version_prefix }} # 输出版本前缀 (例如 0.20.0)
      date_tag: ${{ steps.get_date.outputs.date_tag }}                     # 输出当前日期标签 (例如 20231026)
      date_name: ${{ steps.get_date.outputs.date_name }}                   # 输出当前日期名称 (例如 2023-10-26)
      needs_release: ${{ steps.compare_versions.outputs.needs_release }}   # 输出是否需要发布新版本的标志 (true/false)
    permissions:
      contents: write # 授予写入权限以创建 ./.github/coreos-installer_current_version.txt
      actions: write  # 授予写入权限以上传/下载 artifacts

    steps:
      - name: Checkout your repository # 检出当前仓库代码
        uses: actions/checkout@v4

      - name: Get latest coreos-installer official release info # 获取 coreos-installer 官方最新 Release 信息
        id: get_release
        run: |
          # 使用 GitHub API 获取 coreos-installer 官方仓库的最新 Release
          # 我们需要 jq 来解析 JSON
          sudo apt-get update
          sudo apt-get install -y jq

          RELEASE_INFO=$(curl -s "https://api.github.com/repos/coreos/coreos-installer/releases/latest")
          
          # 检查 RELEASE_INFO 是否为空
          if [ -z "$RELEASE_INFO" ]; then
            echo "错误：未能从 GitHub API 获取最新的 Release 信息。RELEASE_INFO 为空。"
            exit 1
          fi

          # 提取标签名和zipball URL
          TAG_NAME=$(echo "$RELEASE_INFO" | jq -r .tag_name)
          ZIPBALL_URL=$(echo "$RELEASE_INFO" | jq -r .zipball_url)
          VERSION_PREFIX=$(echo "$TAG_NAME" | sed 's/^v//') # 移除标签名前的 'v'

          # 检查提取的值是否为空/null
          if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" = "null" ]; then
            echo "错误：无法从 Release 信息中提取 tag_name。原始 RELEASE_INFO："
            echo "$RELEASE_INFO"
            exit 1
          fi
          if [ -z "$ZIPBALL_URL" ] || [ "$ZIPBALL_URL" = "null" ]; then
            echo "错误：无法从 Release 信息中提取 zipball_url。原始 RELEASE_INFO："
            echo "$RELEASE_INFO"
            exit 1
          fi
          if [ -z "$VERSION_PREFIX" ] || [ "$VERSION_PREFIX" = "null" ]; then
            echo "错误：无法从 tag_name ($TAG_NAME) 中确定 version_prefix。"
            exit 1
          fi

          echo "最新的 coreos-installer Release 标签: $TAG_NAME"
          echo "最新的 coreos-installer zipball URL: $ZIPBALL_URL"
          echo "用于资产的版本前缀: $VERSION_PREFIX"

          # 设置为输出变量
          echo "tag_name=$TAG_NAME" >> "$GITHUB_OUTPUT"
          echo "zipball_url=$ZIPBALL_URL" >> "$GITHUB_OUTPUT"
          echo "version_prefix=$VERSION_PREFIX" >> "$GITHUB_OUTPUT"

      - name: Get Current Date # 获取当前日期
        id: get_date
        run: |
          # 获取当前日期并设置为输出变量
          CURRENT_DATE_TAG=$(date +%Y%m%d)
          CURRENT_DATE_NAME=$(date +%Y-%m-%d)
          echo "date_tag=$CURRENT_DATE_TAG" >> "$GITHUB_OUTPUT"
          echo "date_name=$CURRENT_DATE_NAME" >> "$GITHUB_OUTPUT"
          echo "当前日期标签: $CURRENT_DATE_TAG"
          echo "当前日期名称: $CURRENT_DATE_NAME"

      - name: Prepare current version file # 准备当前版本文件
        id: prepare_current_version
        run: |
          # 将当前的官方版本号保存到文件中，用于后续上传 artifact
          mkdir -p ./.github/ # 确保目录存在
          echo "${{ steps.get_release.outputs.tag_name }}" > ./.github/coreos-installer_current_version.txt
          echo "已将当前版本 ${{ steps.get_release.outputs.tag_name }} 写入 ./.github/coreos-installer_current_version.txt"

      - name: Download previous version artifact # 下载上一次记录的版本号 artifact
        uses: actions/download-artifact@v4
        with:
          name: previous-coreos-version # artifact 名称
          path: ./downloaded_artifacts/ # 下载路径
        continue-on-error: true # 如果 artifact 不存在 (例如首次运行)，则继续执行

      - name: Compare with Previous Version # 与上一个记录的版本进行比较
        id: compare_versions
        run: |
          DOWNLOADED_PREVIOUS_VERSION_FILE="./downloaded_artifacts/previous-coreos-version/coreos-installer_version.txt"
          PREVIOUS_VERSION=""

          if [ -f "$DOWNLOADED_PREVIOUS_VERSION_FILE" ]; then
            PREVIOUS_VERSION=$(cat "$DOWNLOADED_PREVIOUS_VERSION_FILE")
            echo "上一次记录的 coreos-installer 版本号 (来自 artifact): $PREVIOUS_VERSION"
          else
            echo "未找到上一次记录的 coreos-installer 版本号 artifact。"
          fi

          CURRENT_VERSION="${{ steps.get_release.outputs.tag_name }}"
          NEEDS_RELEASE="false"

          # 检查触发事件类型和 force_release 输入
          EVENT_NAME="${{ github.event_name }}"
          FORCE_RELEASE_INPUT="${{ github.event.inputs.force_release }}"

          echo "当前事件名称: $EVENT_NAME"
          echo "强制发布输入: $FORCE_RELEASE_INPUT"
          echo "当前官方最新版本: $CURRENT_VERSION"

          if [ "$EVENT_NAME" = "push" ]; then
              NEEDS_RELEASE="true"
              echo "工作流由 push 事件触发。需要发布新版本 (跳过版本号比较)。"
          elif [ "$FORCE_RELEASE_INPUT" = "true" ]; then
              NEEDS_RELEASE="true"
              echo "强制发布输入为 true。需要发布新版本 (跳过版本号比较)。"
          elif [ -z "$PREVIOUS_VERSION" ]; then # 首次运行或者 artifact 已过期
              NEEDS_RELEASE="true"
              echo "未找到上一个版本号 (首次运行或 artifact 已过期)。需要发布新版本。"
          elif [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
              NEEDS_RELEASE="true"
              echo "官方版本号已更新 (当前: $CURRENT_VERSION, 上次记录: $PREVIOUS_VERSION)。需要发布新版本。"
          else
              echo "官方版本号未发生变化 (均为 $CURRENT_VERSION)。不需要发布新版本。"
          fi

          echo "needs_release=$NEEDS_RELEASE" >> "$GITHUB_OUTPUT"

      - name: Upload current version as artifact # 上传当前版本号作为 artifact
        uses: actions/upload-artifact@v4
        with:
          name: previous-coreos-version # artifact 名称，用于下次比较
          path: ./.github/coreos-installer_current_version.txt # 要上传的文件路径
          # retention-days: 7 # artifact 保留天数，可以根据需要调整或移除以使用默认值
        if: always() # 无论比较结果如何，都尝试上传（如果文件已准备好）

  # 步骤 2: 多架构构建 Job
  build-multi-arch:
    needs: get-latest-release-info # 依赖于获取 Release 信息 Job
    # 仅当 "get-latest-release-info" 步骤指示需要发布时才执行此 Job
    if: ${{ success() && needs.get-latest-release-info.outputs.needs_release == 'true' }}
    runs-on: ubuntu-latest
    env: # 将所需变量提升到 Job 级别环境变量
      RELEASE_ZIP_URL: ${{ needs.get-latest-release-info.outputs.release_url }}
      COREOS_INSTALLER_OFFICIAL_TAG: ${{ needs.get-latest-release-info.outputs.release_tag }}
      RELEASE_VERSION_PREFIX: ${{ needs.get-latest-release-info.outputs.release_version_prefix }}
      ARM64_UBUNTU_PORTS_SOURCES: | # 为 arm64 定义 APT 源文件内容 (来自 ports.ubuntu.com)
        Types: deb
        URIs: http://ports.ubuntu.com/ubuntu-ports
        Suites: noble noble-updates noble-backports noble-security
        Components: main restricted universe multiverse
        Architectures: arm64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
      AMD64_ONLY_UBUNTU_SOURCES: | # 定义一个仅用于 amd64 的主要 Ubuntu 源文件内容
        Types: deb
        URIs: http://azure.archive.ubuntu.com/ubuntu/
        Suites: noble noble-updates noble-backports
        Components: main restricted universe multiverse
        Architectures: amd64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg

        Types: deb
        URIs: http://security.ubuntu.com/ubuntu/
        Suites: noble-security
        Components: main restricted universe multiverse
        Architectures: amd64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
    strategy:
      matrix:
        target:
          - name: x86_64-linux
            rust_target: x86_64-unknown-linux-gnu
            arch_suffix: x86_64
          - name: arm64-linux
            rust_target: aarch64-unknown-linux-gnu
            arch_suffix: aarch64
    permissions:
      contents: read # 只需读取源码
      actions: write # 授予写入权限以上传 artifacts
    steps:
      - name: Checkout your repository # 检出当前仓库代码
        uses: actions/checkout@v4

      - name: Download coreos-installer official release source # 下载 coreos-installer 官方 Release 源码
        id: download_source # 为此步骤添加ID
        run: |
          # 从环境变量中的URL下载源码压缩包
          echo "正在从 ${{ env.RELEASE_ZIP_URL }} 下载源码..."
          curl -L "${{ env.RELEASE_ZIP_URL }}" -o coreos-installer-source.zip
          
          # 检查下载是否成功（简单检查文件是否存在）
          if [ ! -f coreos-installer-source.zip ]; then
            echo "错误：未能下载 coreos-installer-source.zip。使用的 URL: ${{ env.RELEASE_ZIP_URL }}"
            exit 1
          fi
          echo "源码下载完成。"

          unzip -q coreos-installer-source.zip -d coreos-installer-source # -q 安静模式解压
          
          # 找到实际的源码目录
          COREOS_INSTALLER_DIR=$(ls -d coreos-installer-source/*/)
          
          # 检查 COREOS_INSTALLER_DIR 是否找到
          if [ -z "$COREOS_INSTALLER_DIR" ]; then
            echo "错误：解压后未能找到 coreos-installer 源码目录。"
            echo "coreos-installer-source 目录内容:"
            ls -F coreos-installer-source/ || true # 列出内容，如果目录不存在则忽略错误
            exit 1
          fi

          echo "coreos-installer 源码目录: $COREOS_INSTALLER_DIR"
          echo "coreos_installer_dir=$COREOS_INSTALLER_DIR" >> "$GITHUB_OUTPUT" # 设置为步骤输出变量

      - name: Install build dependencies for ${{ matrix.target.name }} # 为 ${{ matrix.target.name }} 安装构建依赖
        run: |
          # 对于所有架构，首先更新现有的 (默认为 amd64) 包列表并安装通用依赖
          sudo apt-get update
          sudo apt-get install -y libzstd-dev pkg-config
          
          if [ "${{ matrix.target.rust_target }}" = "aarch64-unknown-linux-gnu" ]; then
            echo "为 aarch64 配置 APT 以支持多架构..."
            sudo dpkg --add-architecture arm64
            
            echo "覆盖 /etc/apt/sources.list.d/ubuntu.sources 使其仅用于 amd64..."
            echo "$AMD64_ONLY_UBUNTU_SOURCES" | sudo tee /etc/apt/sources.list.d/ubuntu.sources > /dev/null
            # echo "--- /etc/apt/sources.list.d/ubuntu.sources (已修改为仅 amd64) 内容 ---" # 调试时可以取消注释
            # cat /etc/apt/sources.list.d/ubuntu.sources

            echo "创建 arm64 特定源文件指向 ports.ubuntu.com..."
            echo "$ARM64_UBUNTU_PORTS_SOURCES" | sudo tee /etc/apt/sources.list.d/arm64-ubuntu-ports.sources > /dev/null
            # echo "--- /etc/apt/sources.list.d/arm64-ubuntu-ports.sources 内容 ---" # 调试时可以取消注释
            # cat /etc/apt/sources.list.d/arm64-ubuntu-ports.sources

            echo "清理 APT 缓存..."
            sudo apt-get clean
            
            echo "再次更新包列表 (应正确处理 amd64 和 arm64 源)..."
            sudo apt-get update -o Acquire::Retries=3 -o APT::Get::Always-Include-Phased-Updates=true
            
            echo "正在为 aarch64 安装交叉编译工具和 libssl-dev:arm64..."
            # 确保安装时也考虑重试
            sudo apt-get install -y -o Acquire::Retries=3 crossbuild-essential-arm64 libssl-dev:arm64
          else
            # 对于 x86_64 (主机) 构建, 确保主机 OpenSSL 开发库已安装
            echo "正在为主机 (${{ matrix.target.rust_target }}) 安装 libssl-dev..."
            sudo apt-get install -y libssl-dev 
          fi

      - name: Setup Rust toolchain for ${{ matrix.target.name }} # 为 ${{ matrix.target.name }} 设置 Rust 工具链
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true
          target: ${{ matrix.target.rust_target }}

      - name: Build coreos-installer for ${{ matrix.target.name }} # 为 ${{ matrix.target.name }} 构建 coreos-installer
        env: # 通用优化环境变量，适用于所有目标
          CARGO_PROFILE_RELEASE_OPT_LEVEL: "z"
          CARGO_PROFILE_RELEASE_LTO: "fat"
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
          CARGO_PROFILE_RELEASE_PANIC: "abort"
          CARGO_PROFILE_RELEASE_STRIP: "symbols"
        run: |
          echo "开始为 ${{ matrix.target.name }} (Rust target: ${{ matrix.target.rust_target }}) 构建 coreos-installer..."
          cd "${{ steps.download_source.outputs.coreos_installer_dir }}"
          
          echo "当前工作目录: $(pwd)"
          cargo --version
          echo "构建目标: ${{ matrix.target.rust_target }}"

          # 无条件清理可能存在的 OPENSSL 环境变量，以强制依赖 pkg-config
          echo "清理 OPENSSL_* 环境变量以依赖 pkg-config..."
          unset OPENSSL_DIR
          unset OPENSSL_LIB_DIR
          unset OPENSSL_INCLUDE_DIR
          unset PKG_CONFIG_SYSROOT_DIR # 通常在 pkg-config 正确配置后不需要

          if [ "${{ matrix.target.rust_target }}" = "aarch64-unknown-linux-gnu" ]; then
            echo "为 aarch64 配置交叉编译特定环境变量..."
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export AR_aarch64_unknown_linux_gnu=aarch64-linux-gnu-ar
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            
            # 明确指定 pkg-config 可执行文件和路径
            export PKG_CONFIG_SYSROOT_DIR=/ # 尝试设置 sysroot
            export PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig"
            export PKG_CONFIG="aarch64-linux-gnu-pkg-config"
            
            echo "  (aarch64) CC: $CC_aarch64_unknown_linux_gnu"
            echo "  (aarch64) AR: $AR_aarch64_unknown_linux_gnu"
            echo "  (aarch64) LINKER: $CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER"
            echo "  (aarch64) PKG_CONFIG: $(command -v $PKG_CONFIG || echo '未找到')"
            echo "  (aarch64) PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
            echo "  (aarch64) PKG_CONFIG_SYSROOT_DIR: $PKG_CONFIG_SYSROOT_DIR"

            echo "使用 aarch64-linux-gnu-pkg-config 调试 OpenSSL:"
            $PKG_CONFIG --debug --exists --print-errors openssl || echo "openssl 未被 $PKG_CONFIG 找到 (错误码: $?)"
            echo "OpenSSL 版本: $($PKG_CONFIG --modversion openssl || echo '获取版本失败')"
            echo "OpenSSL 库: $($PKG_CONFIG --libs openssl || echo '获取库失败')"
            echo "OpenSSL CFLAGS: $($PKG_CONFIG --cflags openssl || echo '获取 CFLAGS 失败')"

          else
            echo "为主机 (${{ matrix.target.rust_target }}) 配置环境 (OpenSSL 通常无需特殊设置)..."
          fi
          
          echo "执行 cargo build 前的环境变量状态 (相关部分):"
          echo "  OPENSSL_DIR: '${OPENSSL_DIR:-已取消设置}'"
          echo "  OPENSSL_LIB_DIR: '${OPENSSL_LIB_DIR:-已取消设置}'"
          echo "  OPENSSL_INCLUDE_DIR: '${OPENSSL_INCLUDE_DIR:-已取消设置}'"
          echo "  PKG_CONFIG: '${PKG_CONFIG:-未设置或继承}'"
          echo "  PKG_CONFIG_PATH: '${PKG_CONFIG_PATH:-未设置或继承}'"
          echo "  PKG_CONFIG_SYSROOT_DIR: '${PKG_CONFIG_SYSROOT_DIR:-未设置或继承}'"
          
          cargo build --release --locked --target ${{ matrix.target.rust_target }}
          echo "为 ${{ matrix.target.name }} 构建完成。"
          
          cp "target/${{ matrix.target.rust_target }}/release/coreos-installer" "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}"
          echo "已将编译产物复制到 ${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}"

      - name: Calculate SHA256 for ${{ matrix.target.name }} # 为 ${{ matrix.target.name }} 计算 SHA256
        run: |
          # 计算 SHA256 并生成 .sha256 文件
          echo "正在为 ${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }} 计算 SHA256..."
          sha256sum "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}" > "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}.sha256"
          echo "SHA256 文件已生成: ${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}.sha256"
          cat "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}.sha256"

      - name: Upload Artifacts for ${{ matrix.target.name }} # 为 ${{ matrix.target.name }} 上传 Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coreos-installer-${{ matrix.target.arch_suffix }} # 例如: coreos-installer-x86_64, coreos-installer-aarch64
          path: |
            ./coreos-installer-${{ matrix.target.arch_suffix }}
            ./coreos-installer-${{ matrix.target.arch_suffix }}.sha256
          # retention-days: 7 # 单独构建产物的保留天数

  # 步骤 3: 创建 Release Job (在所有构建完成后)
  create-release:
    needs: [get-latest-release-info, build-multi-arch] # 依赖于获取信息和所有构建 Job
    runs-on: ubuntu-latest
    permissions:
      contents: write # 授予写入权限以创建 Release
      actions: read   # 授予读取权限以下载 artifacts (注意：download-artifact v4 不需要 actions:write)

    # 仅当 "get-latest-release-info" 步骤指示需要发布，并且构建成功时才执行此 Job
    if: ${{ success() && needs.get-latest-release-info.outputs.needs_release == 'true' }}
    env: # 将所需变量提升到 Job 级别环境变量
      DATE_TAG: ${{ needs.get-latest-release-info.outputs.date_tag }}
      OFFICIAL_TAG: ${{ needs.get-latest-release-info.outputs.release_tag }}             # 官方 Release 标签 (例如 v0.20.0)
      VERSION_PREFIX: ${{ needs.get-latest-release-info.outputs.release_version_prefix }} # 版本前缀 (例如 0.20.0)
      DATE_NAME: ${{ needs.get-latest-release-info.outputs.date_name }}                   # 日期名称 (例如 2023-10-26)
    steps:
      - name: Download all coreos-installer artifacts # 下载所有 coreos-installer 构建产物
        uses: actions/download-artifact@v4
        with:
          path: ./downloaded_release_assets/ # 所有构建产物下载到这个目录
          # pattern: coreos-installer-* # 可以指定模式，如果还有其他 artifact 的话
          # merge-multiple: true # 如果有多个同名 artifact (不太可能在这里发生)

      - name: List downloaded artifacts # 列出下载的产物 (调试用)
        run: |
          echo "列出下载的 Release 产物目录内容:"
          ls -R ./downloaded_release_assets/

      - name: Prepare release assets # 准备 Release 资产
        run: |
          mkdir -p release_assets # 创建用于存放最终 Release 资产的目录
          
          echo "准备 x86_64 资产..."
          # 复制 x86_64 资产并重命名
          # 路径结构是 ./downloaded_release_assets/<artifact-name>/<file-name>
          cp "./downloaded_release_assets/coreos-installer-x86_64/coreos-installer-x86_64" \
             "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-gnu"
          cp "./downloaded_release_assets/coreos-installer-x86_64/coreos-installer-x86_64.sha256" \
             "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-gnu.sha256"

          echo "准备 aarch64 资产..."
          # 复制 aarch64 资产并重命名
          cp "./downloaded_release_assets/coreos-installer-aarch64/coreos-installer-aarch64" \
             "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-gnu"
          cp "./downloaded_release_assets/coreos-installer-aarch64/coreos-installer-aarch64.sha256" \
             "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-gnu.sha256"
          
          echo "正在生成总的 SHA256SUMS 文件..."
          # 进入 release_assets 目录生成 SHA256SUMS，使其包含相对路径
          (cd release_assets && sha256sum coreos-installer-*) > release_assets/SHA256SUMS
          
          echo "Release 资产准备完成。目录 'release_assets' 内容:"
          ls -l release_assets/

      - name: Create Release # 创建 GitHub Release
        uses: softprops/action-gh-release@v1 # 使用社区维护的 action 来创建 Release
        with:
          # Release 的标签使用官方 Release 的标签，确保与上游一致性
          # 如果您的仓库中已经存在此标签，发布可能会失败或行为不定，取决于 action 的实现
          # 考虑是否需要添加日期或其他标识符以避免冲突，或者设置 prerelease/draft
          tag_name: ${{ env.OFFICIAL_TAG }}-${{ env.DATE_TAG }} # 例如: v0.20.0-20231026
          # Release 的名称可以包含官方标签和您的构建日期
          name: coreos-installer 官方构建 ${{ env.OFFICIAL_TAG }} (每日重构于 ${{ env.DATE_NAME }})
          body: |
            ### `coreos-installer` 官方版本的自动化多架构构建

            这是基于 `coreos-installer` 官方 **${{ env.OFFICIAL_TAG }}** Release 的自动化多架构构建版本。

            **官方 Release 标签:** ${{ env.OFFICIAL_TAG }}
            **本次构建日期:** ${{ env.DATE_NAME }}
            **触发本次构建的提交 (本仓库):** ${{ github.sha }}

            **包含的资产:**
            - `coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-gnu`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-gnu.sha256`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-gnu`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-gnu.sha256`
            - `SHA256SUMS` (包含以上所有二进制文件的校验和)

            *注意: 此构建基于官方发布的源码。请在使用前验证校验和。*
          files: release_assets/* # 上传 'release_assets' 目录下的所有文件
          # draft: false # 设置为 true 则创建草稿 Release
          # prerelease: false # 设置为 true 则标记为预发布版本
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GitHub Token 用于授权创建 Release
