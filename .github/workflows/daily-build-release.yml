# 工作流名称
name: Daily coreos-installer Official Release Build and Publish (MUSL Static Linking)

# 工作流触发条件
on:
  schedule:
    - cron: '0 0 * * *' # 每天 UTC 时间 00:00 (午夜) 运行
  push:
    branches:
      - main # 每次推送到 main 分支时自动运行
  workflow_dispatch:
    # 允许手动触发此工作流
    inputs:
      force_release:
        description: '强制发布新版本，即使版本号没有变化' # 完全使用中文描述
        required: false
        default: false
        type: boolean

jobs:
  # 步骤 1: 获取最新 Release 信息并决定是否需要发布
  get-latest-release-info:
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.get_official_release.outputs.official_release_tag }}      # 输出官方 coreos-installer 的最新 Release 标签
      release_url: ${{ steps.get_official_release.outputs.official_zipball_url }}      # 输出官方 coreos-installer 最新 Release 的源码下载 URL
      release_version_prefix: ${{ steps.get_official_release.outputs.official_version_prefix }} # 输出从官方标签提取的版本前缀
      date_tag: ${{ steps.get_date.outputs.date_tag }}                                # 输出当前日期标签 (例如 20231026)
      date_name: ${{ steps.get_date.outputs.date_name }}                              # 输出当前日期名称 (例如 2023-10-26)
      needs_release: ${{ steps.determine_release_need.outputs.needs_release }}        # 输出是否需要发布新版本的标志 (true/false)
    permissions:
      contents: read # 检出代码和进行 API 调用（针对本仓库）通常需要读取权限

    steps:
      - name: Checkout your repository # 检出当前仓库代码
        uses: actions/checkout@v4

      - name: Get latest coreos-installer official release info # 获取 coreos-installer 官方最新 Release 信息
        id: get_official_release
        run: |
          # 安装 jq
          sudo apt-get update && sudo apt-get install -y jq
          OFFICIAL_RELEASE_INFO=$(curl -s -L "https://api.github.com/repos/coreos/coreos-installer/releases/latest")
          if [ -z "$OFFICIAL_RELEASE_INFO" ] || [ "$(echo "$OFFICIAL_RELEASE_INFO" | jq -r .message)" = "Not Found" ]; then
            echo "错误：未能从 coreos/coreos-installer 获取最新的 Release 信息。"
            exit 1
          fi
          OFFICIAL_TAG_NAME=$(echo "$OFFICIAL_RELEASE_INFO" | jq -r .tag_name)
          OFFICIAL_ZIPBALL_URL=$(echo "$OFFICIAL_RELEASE_INFO" | jq -r .zipball_url)
          OFFICIAL_VERSION_PREFIX=$(echo "$OFFICIAL_TAG_NAME" | sed 's/^v//')

          if [ -z "$OFFICIAL_TAG_NAME" ] || [ "$OFFICIAL_TAG_NAME" = "null" ]; then echo "错误：无法从官方 Release 信息中提取 tag_name。" >&2; exit 1; fi
          if [ -z "$OFFICIAL_ZIPBALL_URL" ] || [ "$OFFICIAL_ZIPBALL_URL" = "null" ]; then echo "错误：无法从官方 Release 信息中提取 zipball_url。" >&2; exit 1; fi
          if [ -z "$OFFICIAL_VERSION_PREFIX" ] || [ "$OFFICIAL_VERSION_PREFIX" = "null" ]; then echo "错误：无法从官方 tag_name ($OFFICIAL_TAG_NAME) 中确定 version_prefix。" >&2; exit 1; fi

          echo "官方 coreos-installer 最新 Release 标签: $OFFICIAL_TAG_NAME"
          echo "官方 coreos-installer 最新 zipball URL: $OFFICIAL_ZIPBALL_URL"
          echo "官方 coreos-installer 版本前缀: $OFFICIAL_VERSION_PREFIX"

          echo "official_release_tag=$OFFICIAL_TAG_NAME" >> "$GITHUB_OUTPUT"
          echo "official_zipball_url=$OFFICIAL_ZIPBALL_URL" >> "$GITHUB_OUTPUT"
          echo "official_version_prefix=$OFFICIAL_VERSION_PREFIX" >> "$GITHUB_OUTPUT"

      - name: Get Current Date # 获取当前日期
        id: get_date
        run: |
          CURRENT_DATE_TAG=$(date +%Y%m%d)
          CURRENT_DATE_NAME=$(date +%Y-%m-%d)
          echo "date_tag=$CURRENT_DATE_TAG" >> "$GITHUB_OUTPUT"
          echo "date_name=$CURRENT_DATE_NAME" >> "$GITHUB_OUTPUT"
          echo "当前日期标签: $CURRENT_DATE_TAG"
          echo "当前日期名称: $CURRENT_DATE_NAME"

      - name: Get latest own repository release info # 获取本仓库的最新 Release 信息
        id: get_own_latest_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 使用 GITHUB_TOKEN 进行认证
        run: |
          OWN_RELEASE_INFO=$(curl -s -L -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ github.repository }}/releases/latest")
          OWN_LATEST_RELEASE_TAG="" # 默认为空字符串

          # 检查API调用是否成功并且返回了有效的JSON
          if echo "$OWN_RELEASE_INFO" | jq -e .tag_name > /dev/null 2>&1; then
            OWN_LATEST_RELEASE_TAG=$(echo "$OWN_RELEASE_INFO" | jq -r .tag_name)
            echo "本仓库最新 Release 标签: $OWN_LATEST_RELEASE_TAG"
          else
            # 如果 jq 失败 (例如因为 "Not Found" 消息不是有效 JSON 或 .tag_name 不存在)
            echo "本仓库中未找到 Release，或无法解析最新的 Release 信息。"
            # OWN_LATEST_RELEASE_TAG 保持为空
          fi
          echo "own_latest_release_tag=$OWN_LATEST_RELEASE_TAG" >> "$GITHUB_OUTPUT"

      - name: Determine if Release is Needed # 根据版本比较决定是否需要发布
        id: determine_release_need
        run: |
          CURRENT_OFFICIAL_TAG="${{ steps.get_official_release.outputs.official_release_tag }}"
          OWN_LATEST_TAG_FULL="${{ steps.get_own_latest_release.outputs.own_latest_release_tag }}"
          
          PREVIOUS_OFFICIAL_EQUIVALENT_TAG=""
          if [ -n "$OWN_LATEST_TAG_FULL" ] && [ "$OWN_LATEST_TAG_FULL" != "null" ]; then
            # 从本仓库的 Release 标签 (例如 v0.24.0-20250521-musl) 提取核心版本部分 (例如 v0.24.0)
            PREVIOUS_OFFICIAL_EQUIVALENT_TAG=$(echo "$OWN_LATEST_TAG_FULL" | sed -E 's/(-[0-9]+)?-musl$//')
            echo "本仓库最新 Release 标签中的核心版本部分: $PREVIOUS_OFFICIAL_EQUIVALENT_TAG"
          else
            echo "本仓库中未找到之前的有效 Release 标签。"
          fi

          NEEDS_RELEASE="false"
          EVENT_NAME="${{ github.event_name }}"
          FORCE_RELEASE_INPUT="${{ github.event.inputs.force_release }}"

          echo "当前事件名称: $EVENT_NAME"
          echo "强制发布输入: $FORCE_RELEASE_INPUT"
          echo "CoreOS/coreos-installer 最新官方 Release 标签: $CURRENT_OFFICIAL_TAG"

          if [ "$EVENT_NAME" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then # 仅当推送到 main 分支时
              NEEDS_RELEASE="true"
              echo "工作流由 push 到 main 事件触发。需要发布新版本 (跳过版本号比较)。"
          elif [ "$FORCE_RELEASE_INPUT" = "true" ]; then
              NEEDS_RELEASE="true"
              echo "强制发布输入为 true。需要发布新版本 (跳过版本号比较)。"
          elif [ -z "$PREVIOUS_OFFICIAL_EQUIVALENT_TAG" ]; then
              NEEDS_RELEASE="true"
              echo "本仓库中未找到之前的有效 Release 或无法解析其核心版本。需要发布新版本。"
          elif [ "$CURRENT_OFFICIAL_TAG" != "$PREVIOUS_OFFICIAL_EQUIVALENT_TAG" ]; then
              NEEDS_RELEASE="true"
              echo "官方 coreos-installer 版本已更新 (官方最新: $CURRENT_OFFICIAL_TAG, 本仓库上次构建基于的官方版本: $PREVIOUS_OFFICIAL_EQUIVALENT_TAG)。需要发布新版本。"
          else
              echo "官方 coreos-installer 版本未发生变化 (均为 $CURRENT_OFFICIAL_TAG，与本仓库上次构建基于的官方版本一致)。不需要发布新版本 (除非是 push 到 main 或强制发布)。"
              if [ "$EVENT_NAME" = "schedule" ]; then
                NEEDS_RELEASE="false" # 对于计划运行，如果版本匹配则明确为false
              fi
          fi
          echo "needs_release=$NEEDS_RELEASE" >> "$GITHUB_OUTPUT"

  # 步骤 2: 多架构构建 Job (MUSL)
  build-multi-arch-musl:
    name: Build for ${{ matrix.target.name }} (MUSL)
    needs: get-latest-release-info # 依赖于获取 Release 信息 Job
    if: ${{ success() && needs.get-latest-release-info.outputs.needs_release == 'true' }}
    runs-on: ubuntu-latest
    env: 
      RELEASE_ZIP_URL: ${{ needs.get-latest-release-info.outputs.release_url }}
      COREOS_INSTALLER_OFFICIAL_TAG: ${{ needs.get-latest-release-info.outputs.release_tag }} 
      RELEASE_VERSION_PREFIX: ${{ needs.get-latest-release-info.outputs.release_version_prefix }}
      # amd64 主源 (azure)
      AMD64_MAIN_UBUNTU_SOURCES: |
        Types: deb
        URIs: http://azure.archive.ubuntu.com/ubuntu/
        Suites: noble noble-updates noble-backports
        Components: main restricted universe multiverse
        Architectures: amd64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
      # amd64 安全源 (security.ubuntu.com)
      AMD64_SECURITY_UBUNTU_SOURCES: |
        Types: deb
        URIs: http://security.ubuntu.com/ubuntu/
        Suites: noble-security
        Components: main restricted universe multiverse
        Architectures: amd64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
      # arm64 源 (ports.ubuntu.com)
      ARM64_UBUNTU_PORTS_SOURCES: |
        Types: deb
        URIs: http://ports.ubuntu.com/ubuntu-ports
        Suites: noble noble-updates noble-backports noble-security
        Components: main restricted universe multiverse
        Architectures: arm64
        Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg
    strategy:
      matrix:
        target:
          - name: x86_64-linux-musl
            rust_target: x86_64-unknown-linux-musl
            arch_suffix: x86_64-musl
            c_compiler: musl-gcc 
            # target_cflags: "-I/usr/include/x86_64-linux-gnu" # 已移除
            target_lib_path: "/usr/lib/x86_64-linux-gnu"
            target_pkgconfig_libdir: "/usr/lib/x86_64-linux-gnu/pkgconfig"
          - name: arm64-linux-musl
            rust_target: aarch64-unknown-linux-musl
            arch_suffix: aarch64-musl
            c_compiler: aarch64-linux-gnu-gcc 
            target_cflags: "-I/usr/include/aarch64-linux-gnu" 
            target_lib_path: "/usr/lib/aarch64-linux-gnu"
            target_pkgconfig_libdir: "/usr/lib/aarch64-linux-gnu/pkgconfig"
    permissions:
      contents: read 
      actions: write 
    steps:
      - name: Checkout your repository 
        uses: actions/checkout@v4

      - name: Download coreos-installer official release source 
        id: download_source
        run: |
          echo "正在从 ${{ env.RELEASE_ZIP_URL }} 下载源码..."
          curl -L "${{ env.RELEASE_ZIP_URL }}" -o coreos-installer-source.zip
          if [ ! -f coreos-installer-source.zip ]; then
            echo "错误：未能下载 coreos-installer-source.zip。"
            exit 1
          fi
          unzip -q coreos-installer-source.zip -d coreos-installer-source
          COREOS_INSTALLER_DIR=$(find coreos-installer-source -mindepth 1 -maxdepth 1 -type d -print -quit) 
          if [ -z "$COREOS_INSTALLER_DIR" ]; then
            echo "错误：解压后未能找到 coreos-installer 源码目录。"
            ls -R coreos-installer-source 
            exit 1
          fi
          echo "coreos_installer_dir=$COREOS_INSTALLER_DIR" >> "$GITHUB_OUTPUT"
          echo "源码解压到: $COREOS_INSTALLER_DIR"

      - name: Install build dependencies for ${{ matrix.target.name }} 
        run: |
          set -x 
          sudo apt-get update
          sudo apt-get install -y musl-tools pkg-config libssl-dev libzstd-dev 
          
          if [ "${{ matrix.target.rust_target }}" = "aarch64-unknown-linux-musl" ]; then
            echo "为 aarch64-musl 配置 APT 以支持多架构依赖..."
            sudo dpkg --add-architecture arm64
            
            echo "清理现有的 APT 源配置..."
            if [ -f /etc/apt/sources.list ]; then
              sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak.${{ github.run_id }}
              echo "已备份 /etc/apt/sources.list"
            fi
            sudo rm -f /etc/apt/sources.list.d/*
            echo "已清理 /etc/apt/sources.list.d/"

            echo "写入 amd64 主源 (azure)..."
            echo "${{ env.AMD64_MAIN_UBUNTU_SOURCES }}" | sudo tee /etc/apt/sources.list.d/ubuntu-amd64-main.sources > /dev/null
            
            echo "写入 arm64 源 (ports)..."
            echo "${{ env.ARM64_UBUNTU_PORTS_SOURCES }}" | sudo tee /etc/apt/sources.list.d/ubuntu-arm64-ports.sources > /dev/null

            echo "当前 /etc/apt/sources.list.d/ 内容:"
            ls -l /etc/apt/sources.list.d/
            echo "ubuntu-amd64-main.sources 内容:"
            sudo cat /etc/apt/sources.list.d/ubuntu-amd64-main.sources || echo "文件不存在"
            echo "ubuntu-arm64-ports.sources 内容:"
            sudo cat /etc/apt/sources.list.d/ubuntu-arm64-ports.sources || echo "文件不存在"

            echo "运行 apt-get clean 和 apt-get update (针对 arm64)..."
            sudo apt-get clean
            sudo apt-get update -o Acquire::Retries=3 -o APT::Get::Always-Include-Phased-Updates=true
            
            echo "安装 arm64 交叉编译工具和开发库..."
            sudo apt-get install -y -o Acquire::Retries=3 crossbuild-essential-arm64 libssl-dev:arm64 libzstd-dev:arm64
            
            echo "验证 aarch64 OpenSSL .pc 和 .a 文件..."
            if ! ls -l /usr/lib/aarch64-linux-gnu/pkgconfig/openssl.pc /usr/lib/aarch64-linux-gnu/libssl.a /usr/lib/aarch64-linux-gnu/libcrypto.a > /dev/null 2>&1; then
                echo "错误: aarch64 的 OpenSSL .pc 或 .a 文件未找到。检查 /usr/lib/aarch64-linux-gnu/ 和其 pkgconfig 子目录。"
                ls -lR /usr/lib/aarch64-linux-gnu/
                exit 1
            fi
            echo "验证 aarch64 Zstd .pc 和 .a 文件..."
            if ! ls -l /usr/lib/aarch64-linux-gnu/pkgconfig/libzstd.pc /usr/lib/aarch64-linux-gnu/libzstd.a > /dev/null 2>&1; then
                echo "错误: aarch64 的 Zstd .pc 或 .a 文件未找到。" ; exit 1
            fi
            echo "aarch64 OpenSSL 和 Zstd 依赖已安装。"

          else 
            echo "为主机 (x86_64) musl 构建，依赖已在前面通过 apt-get install 安装。"
            
            echo "验证主机 OpenSSL .pc 和 .a 文件..."
            if ! ls -l /usr/lib/x86_64-linux-gnu/pkgconfig/openssl.pc /usr/lib/x86_64-linux-gnu/libssl.a /usr/lib/x86_64-linux-gnu/libcrypto.a > /dev/null 2>&1; then
                echo "错误: 主机的 OpenSSL .pc 或 .a 文件未在 /usr/lib/x86_64-linux-gnu/ 中找到。" ; exit 1
            fi
            echo "验证主机 Zstd .pc 和 .a 文件..."
            if ! ls -l /usr/lib/x86_64-linux-gnu/pkgconfig/libzstd.pc /usr/lib/x86_64-linux-gnu/libzstd.a > /dev/null 2>&1; then
                echo "错误: 主机的 Zstd .pc 或 .a 文件未在 /usr/lib/x86_64-linux-gnu/ 中找到。" ; exit 1
            fi
            echo "主机 OpenSSL 和 Zstd 的 .pc 和 .a 文件已找到。"
          fi

      - name: Setup Rust toolchain for ${{ matrix.target.name }} 
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true
          target: ${{ matrix.target.rust_target }}

      - name: Build coreos-installer for ${{ matrix.target.name }} 
        env: 
          CARGO_PROFILE_RELEASE_OPT_LEVEL: "z"
          CARGO_PROFILE_RELEASE_LTO: "fat"
          CARGO_PROFILE_RELEASE_CODEGEN_UNITS: "1"
          CARGO_PROFILE_RELEASE_PANIC: "abort"
          CARGO_PROFILE_RELEASE_STRIP: "symbols"
          OPENSSL_STATIC: "true" 
          ZSTD_STATIC: "true"
        run: |
          set -x 
          echo "开始为 ${{ matrix.target.name }} (Rust target: ${{ matrix.target.rust_target }}) 构建 coreos-installer..."
          cd "${{ steps.download_source.outputs.coreos_installer_dir }}"
          
          if [ -d "/usr/include" ]; then 
              export ZSTD_INCLUDE_DIR="/usr/include" # Zstd 通常能通过 pkg-config 找到，或其头文件在标准路径
          fi
          
          if [[ "${{ matrix.target.rust_target }}" == "x86_64-unknown-linux-musl" ]]; then
            export CC="${{ matrix.target.c_compiler }}" 
            export CXX="musl-g++" 
            export CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER="${{ matrix.target.c_compiler }}"
            
            # 为 openssl-sys 精确设置环境变量
            export OPENSSL_DIR="/usr" # 指向包含 include/openssl 和 lib 的基础目录
            export OPENSSL_LIB_DIR="${{ matrix.target.target_lib_path }}" # /usr/lib/x86_64-linux-gnu
            # 通过 OPENSSL_CFLAGS 传递架构特定的头文件路径给 openssl-sys 的构建脚本
            export OPENSSL_CFLAGS="-I/usr/include/x86_64-linux-gnu"
            
            export ZSTD_LIB_DIR="${{ matrix.target.target_lib_path }}" 
            
            HOST_PKG_CONFIG=$(command -v pkg-config)
            if [ -z "$HOST_PKG_CONFIG" ]; then echo "错误: 主机 pkg-config 未找到。" >&2; exit 1; fi
            export PKG_CONFIG="$HOST_PKG_CONFIG"
            export PKG_CONFIG_LIBDIR="${{ matrix.target.target_pkgconfig_libdir }}" 

            export RUSTFLAGS="-Lnative=${{ matrix.target.target_lib_path }}" 
            export LIBRARY_PATH="${{ matrix.target.target_lib_path }}:${LIBRARY_PATH:-}"

            echo "  (x86_64-musl) CC: $CC, CXX: $CXX, LINKER: $CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER"
            echo "  (x86_64-musl) OPENSSL_DIR: $OPENSSL_DIR"
            echo "  (x86_64-musl) OPENSSL_LIB_DIR: $OPENSSL_LIB_DIR"
            echo "  (x86_64-musl) OPENSSL_CFLAGS: $OPENSSL_CFLAGS"
            echo "  (x86_64-musl) ZSTD_LIB_DIR: $ZSTD_LIB_DIR, ZSTD_INCLUDE_DIR: $ZSTD_INCLUDE_DIR"
            echo "  (x86_64-musl) PKG_CONFIG: $PKG_CONFIG, PKG_CONFIG_LIBDIR: $PKG_CONFIG_LIBDIR"
            echo "  (x86_64-musl) RUSTFLAGS: $RUSTFLAGS, LIBRARY_PATH: $LIBRARY_PATH"
            
            echo "尝试 pkg-config for openssl (可能仍然失败，但 OPENSSL_* 变量应优先):"
            $PKG_CONFIG --static --print-errors --cflags --libs openssl || echo "  pkg-config openssl (static) 失败或未找到."
            echo "尝试 pkg-config for libzstd:"
            $PKG_CONFIG --static --print-errors --cflags --libs libzstd || echo "  pkg-config libzstd (static) 失败或未找到."


          elif [[ "${{ matrix.target.rust_target }}" == "aarch64-unknown-linux-musl" ]]; then
            export CC="${{ matrix.target.c_compiler }}" 
            export CXX="aarch64-linux-gnu-g++"
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER="${{ matrix.target.c_compiler }}"
            
            export OPENSSL_DIR="/usr" # 对于交叉编译，这指向主机的 /usr，但 include/lib 路径会被覆盖
            export OPENSSL_LIB_DIR="${{ matrix.target.target_lib_path }}" # /usr/lib/aarch64-linux-gnu
            export OPENSSL_INCLUDE_DIR="/usr/include/aarch64-linux-gnu" # 明确指定 aarch64 的 include 路径
                                                                    # 同时，OPENSSL_DIR="/usr" 也能帮助找到 /usr/include/openssl
            
            export ZSTD_LIB_DIR="${{ matrix.target.target_lib_path }}"    
            export ZSTD_INCLUDE_DIR="/usr/include/aarch64-linux-gnu" # 如果 zstd:arm64 的头文件也在这里
            # 如果 zstd:arm64 的头文件在 /usr/include，则 ZSTD_INCLUDE_DIR="${ZSTD_INCLUDE_DIR}" (来自通用设置) 即可

            # CFLAGS_aarch64_unknown_linux_musl 仍然有用，因为它会被 cc crate 用于编译传递给它的C文件
            export CFLAGS_aarch64_unknown_linux_musl="${{ matrix.target.target_cflags }}" # -I/usr/include/aarch64-linux-gnu

            HOST_PKG_CONFIG=$(command -v pkg-config)
            if [ -z "$HOST_PKG_CONFIG" ]; then echo "错误: 主机 pkg-config 未找到。" >&2; exit 1; fi
            export PKG_CONFIG="$HOST_PKG_CONFIG"
            export PKG_CONFIG_LIBDIR="${{ matrix.target.target_pkgconfig_libdir }}" # /usr/lib/aarch64-linux-gnu/pkgconfig
            
            export RUSTFLAGS="-Lnative=${{ matrix.target.target_lib_path }}" 
            export LIBRARY_PATH="${{ matrix.target.target_lib_path }}:${LIBRARY_PATH:-}"
            echo "  (aarch64-musl) CC: $CC, CXX: $CXX, LINKER: $CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER"
            echo "  (aarch64-musl) OPENSSL_DIR: $OPENSSL_DIR"
            echo "  (aarch64-musl) OPENSSL_LIB_DIR: $OPENSSL_LIB_DIR, OPENSSL_INCLUDE_DIR: $OPENSSL_INCLUDE_DIR"
            echo "  (aarch64-musl) ZSTD_LIB_DIR: $ZSTD_LIB_DIR, ZSTD_INCLUDE_DIR: $ZSTD_INCLUDE_DIR"
            echo "  (aarch64-musl) PKG_CONFIG: $PKG_CONFIG, PKG_CONFIG_LIBDIR: $PKG_CONFIG_LIBDIR"
            echo "  (aarch64-musl) RUSTFLAGS: $RUSTFLAGS, LIBRARY_PATH: $LIBRARY_PATH"
            echo "  (aarch64-musl) CFLAGS_aarch64_unknown_linux_musl: $CFLAGS_aarch64_unknown_linux_musl"
            $PKG_CONFIG --static --print-errors --cflags --libs openssl || echo "  pkg-config openssl (static, aarch64) 失败或未找到."
            $PKG_CONFIG --static --print-errors --cflags --libs libzstd || echo "  pkg-config libzstd (static, aarch64) 失败或未找到."
          fi
          
          echo "当前环境变量给 Cargo (构建前):"
          env | grep -E 'OPENSSL_|ZSTD_|CC|CXX|CFLAGS|RUSTFLAGS|LIBRARY_PATH|PKG_CONFIG' | sort

          cargo build --release --locked --target ${{ matrix.target.rust_target }} -v 
          echo "为 ${{ matrix.target.name }} 构建完成。"
          
          cp "target/${{ matrix.target.rust_target }}/release/coreos-installer" "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}"

      - name: Calculate SHA256 for ${{ matrix.target.name }} 
        run: |
          sha256sum "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}" > "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}.sha256"
          cat "${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}.sha256"

      - name: Upload Artifacts for ${{ matrix.target.name }}
        uses: actions/upload-artifact@v4
        with:
          name: coreos-installer-${{ matrix.target.arch_suffix }}
          path: |
            ${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}
            ${{ github.workspace }}/coreos-installer-${{ matrix.target.arch_suffix }}.sha256
          retention-days: 7

  # 步骤 3: 创建 Release Job (MUSL)
  create-release-musl:
    name: Create MUSL Release
    needs: [get-latest-release-info, build-multi-arch-musl] 
    runs-on: ubuntu-latest
    permissions:
      contents: write  
      actions: read    
    if: ${{ success() && needs.get-latest-release-info.outputs.needs_release == 'true' }}
    env: 
      DATE_TAG: ${{ needs.get-latest-release-info.outputs.date_tag }}
      OFFICIAL_TAG: ${{ needs.get-latest-release-info.outputs.release_tag }}
      VERSION_PREFIX: ${{ needs.get-latest-release-info.outputs.release_version_prefix }}
      DATE_NAME: ${{ needs.get-latest-release-info.outputs.date_name }}
    steps:
      - name: Download all coreos-installer MUSL artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./downloaded_release_assets/ 

      - name: List downloaded artifacts 
        run: |
          echo "下载的资产结构:"
          ls -R ./downloaded_release_assets/

      - name: Prepare release assets 
        id: prepare_assets
        run: |
          mkdir -p release_assets 
          ASSET_LIST="" 

          for arch_dir in ./downloaded_release_assets/coreos-installer-*-musl; do
            if [ -d "$arch_dir" ]; then
              arch_suffix=$(basename "$arch_dir" | sed 's/coreos-installer-//') 
              rust_target_suffix=$(echo "$arch_suffix" | sed 's/-musl/-unknown-linux-musl/') 
              if [[ "$arch_suffix" == "aarch64-musl" ]]; then 
                  rust_target_suffix="aarch64-unknown-linux-musl"
              fi

              echo "准备 ${arch_suffix} 版本化资产..."
              cp "${arch_dir}/coreos-installer-${arch_suffix}" \
                 "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-${rust_target_suffix}"
              ASSET_LIST="${ASSET_LIST}release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-${rust_target_suffix}\n"
              cp "${arch_dir}/coreos-installer-${arch_suffix}.sha256" \
                 "release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-${rust_target_suffix}.sha256"
              ASSET_LIST="${ASSET_LIST}release_assets/coreos-installer-${{ env.VERSION_PREFIX }}-${rust_target_suffix}.sha256\n"

              echo "准备 ${arch_suffix} 固定名称资产 (latest)..."
              cp "${arch_dir}/coreos-installer-${arch_suffix}" \
                 "release_assets/coreos-installer-${arch_suffix}-latest"
              ASSET_LIST="${ASSET_LIST}release_assets/coreos-installer-${arch_suffix}-latest\n"
              cp "${arch_dir}/coreos-installer-${arch_suffix}.sha256" \
                 "release_assets/coreos-installer-${arch_suffix}-latest.sha256"
              ASSET_LIST="${ASSET_LIST}release_assets/coreos-installer-${arch_suffix}-latest.sha256\n"
            fi
          done
          
          echo "正在生成总的 SHA256SUMS 文件 (MUSL)..."
          (cd release_assets && sha256sum \
            coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-musl \
            coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-musl \
            coreos-installer-x86_64-musl-latest \
            coreos-installer-aarch64-musl-latest \
          ) > release_assets/SHA256SUMS-musl 
          ASSET_LIST="${ASSET_LIST}release_assets/SHA256SUMS-musl\n"

          echo "Release MUSL 资产准备完成。目录 'release_assets' 内容:"
          ls -l release_assets/
          
          echo "asset_files=$(echo -e "$ASSET_LIST" | tr '\n' ' ' | sed 's/ $//')" >> "$GITHUB_OUTPUT"


      - name: Create Release (MUSL) 
        uses: softprops/action-gh-release@v1 
        with:
          tag_name: ${{ env.OFFICIAL_TAG }}-${{ env.DATE_TAG }}-musl 
          name: coreos-installer 官方构建 ${{ env.OFFICIAL_TAG }} (MUSL 静态链接, ${{ env.DATE_NAME }})
          body: |
            ### `coreos-installer` 官方版本的自动化多架构构建 (MUSL 静态链接)

            这是基于 `coreos-installer` 官方 **${{ env.OFFICIAL_TAG }}** Release 的自动化多架构构建版本，使用 MUSL Libc 进行静态链接。

            **官方 Release 标签:** ${{ env.OFFICIAL_TAG }}
            **本次构建日期:** ${{ env.DATE_NAME }}
            **触发本次构建的提交 (本仓库):** `${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}`

            **包含的资产 (MUSL):**
            *版本化资产:*
            - `coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-musl`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-x86_64-unknown-linux-musl.sha256`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-musl`
            - `coreos-installer-${{ env.VERSION_PREFIX }}-aarch64-unknown-linux-musl.sha256`

            *固定名称最新资产 (指向此 Release 中的对应架构 MUSL 文件):*
            - `coreos-installer-x86_64-musl-latest`
            - `coreos-installer-x86_64-musl-latest.sha256`
            - `coreos-installer-aarch64-musl-latest`
            - `coreos-installer-aarch64-musl-latest.sha256`
            
            - `SHA256SUMS-musl` (包含以上所有 MUSL 二进制文件的校验和)

            *注意: 此构建基于官方发布的源码。请在使用前验证校验和。*
          files: ${{ steps.prepare_assets.outputs.asset_files }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
